
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Wed May 02 17:56:57 CEST 2018
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Wed May 02 17:56:57 CEST 2018
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\136\000\002\002\004\000\002\046\002\000\002\002" +
    "\004\000\002\047\002\000\002\045\004\000\002\003\004" +
    "\000\002\003\003\000\002\004\004\000\002\004\003\000" +
    "\002\005\004\000\002\005\003\000\002\006\004\000\002" +
    "\006\003\000\002\010\006\000\002\012\007\000\002\015" +
    "\005\000\002\015\005\000\002\016\005\000\002\014\004" +
    "\000\002\014\004\000\002\017\004\000\002\017\006\000" +
    "\002\017\006\000\002\017\005\000\002\017\007\000\002" +
    "\017\007\000\002\020\004\000\002\020\005\000\002\050" +
    "\002\000\002\051\002\000\002\021\010\000\002\052\002" +
    "\000\002\053\002\000\002\021\010\000\002\007\007\000" +
    "\002\023\004\000\002\023\005\000\002\024\005\000\002" +
    "\024\007\000\002\022\003\000\002\022\003\000\002\035" +
    "\004\000\002\035\005\000\002\036\003\000\002\011\004" +
    "\000\002\011\003\000\002\011\003\000\002\013\004\000" +
    "\002\013\003\000\002\013\003\000\002\037\003\000\002" +
    "\037\004\000\002\037\003\000\002\037\004\000\002\040" +
    "\003\000\002\040\003\000\002\040\003\000\002\040\003" +
    "\000\002\040\004\000\002\040\004\000\002\040\003\000" +
    "\002\026\005\000\002\026\007\000\002\027\003\000\002" +
    "\027\003\000\002\027\005\000\002\027\003\000\002\027" +
    "\005\000\002\027\005\000\002\027\005\000\002\027\005" +
    "\000\002\027\005\000\002\025\003\000\002\025\003\000" +
    "\002\030\004\000\002\031\004\000\002\031\005\000\002" +
    "\032\003\000\002\032\005\000\002\033\003\000\002\033" +
    "\005\000\002\041\007\000\002\041\007\000\002\041\011" +
    "\000\002\041\011\000\002\041\011\000\002\041\011\000" +
    "\002\042\007\000\002\042\007\000\002\043\007\000\002" +
    "\043\006\000\002\044\007\000\002\034\005\000\002\034" +
    "\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\271\000\012\004\000\005\000\010\000\015\000\001" +
    "\002\000\004\002\273\001\002\000\012\004\ufffe\005\ufffe" +
    "\010\ufffe\015\ufffe\001\002\000\012\004\025\005\010\010" +
    "\012\015\013\001\002\000\004\002\uffff\001\002\000\004" +
    "\004\270\001\002\000\012\004\025\005\010\010\012\015" +
    "\013\001\002\000\004\004\266\001\002\000\006\004\255" +
    "\011\256\001\002\000\004\002\ufff9\001\002\000\006\027" +
    "\252\030\253\001\002\000\006\027\244\030\245\001\002" +
    "\000\004\002\ufff5\001\002\000\004\002\ufffb\001\002\000" +
    "\006\010\242\015\013\001\002\000\004\002\ufff7\001\002" +
    "\000\010\004\025\010\031\015\013\001\002\000\004\002" +
    "\ufffd\001\002\000\004\004\030\001\002\000\010\004\025" +
    "\010\012\015\013\001\002\000\004\002\ufffa\001\002\000" +
    "\006\027\uffe7\030\uffe7\001\002\000\004\004\033\001\002" +
    "\000\004\002\ufff8\001\002\000\012\021\uffe5\027\uffed\030" +
    "\uffed\035\035\001\002\000\004\021\040\001\002\000\006" +
    "\004\037\020\036\001\002\000\006\027\uffec\030\uffec\001" +
    "\002\000\006\027\uffeb\030\uffeb\001\002\000\010\004\226" +
    "\010\231\022\225\001\002\000\004\025\uffe4\001\002\000" +
    "\004\025\044\001\002\000\006\010\uffe3\015\uffe3\001\002" +
    "\000\024\004\070\006\061\010\072\012\064\013\060\014" +
    "\056\016\053\025\044\026\066\001\002\000\024\004\uffc9" +
    "\006\uffc9\007\uffc9\012\uffc9\013\uffc9\014\uffc9\016\uffc9\025" +
    "\uffc9\026\uffc9\001\002\000\004\026\uffd3\001\002\000\024" +
    "\004\uffc5\006\uffc5\007\uffc5\012\uffc5\013\uffc5\014\uffc5\016" +
    "\uffc5\025\uffc5\026\uffc5\001\002\000\024\004\070\006\061" +
    "\010\072\012\064\013\060\014\056\016\053\025\044\026" +
    "\uffd4\001\002\000\004\026\uffd0\001\002\000\024\004\uffc8" +
    "\006\uffc8\007\uffc8\012\uffc8\013\uffc8\014\uffc8\016\uffc8\025" +
    "\uffc8\026\uffc8\001\002\000\004\021\217\001\002\000\024" +
    "\004\uffcb\006\uffcb\007\uffcb\012\uffcb\013\uffcb\014\uffcb\016" +
    "\uffcb\025\uffcb\026\uffcb\001\002\000\022\004\163\006\061" +
    "\012\064\013\060\014\056\016\053\025\044\026\uffcf\001" +
    "\002\000\012\004\147\020\130\021\131\030\213\001\002" +
    "\000\004\026\uffd6\001\002\000\004\021\205\001\002\000" +
    "\004\021\172\001\002\000\004\030\171\001\002\000\004" +
    "\026\170\001\002\000\004\021\164\001\002\000\022\004" +
    "\163\006\061\012\064\013\060\014\056\016\053\025\044" +
    "\026\uffcd\001\002\000\032\002\uffd8\004\uffd8\006\uffd8\007" +
    "\uffd8\010\uffd8\012\uffd8\013\uffd8\014\uffd8\015\uffd8\016\uffd8" +
    "\025\uffd8\026\uffd8\001\002\000\004\030\161\001\002\000" +
    "\012\004\030\021\113\023\110\035\111\001\002\000\024" +
    "\004\uffca\006\uffca\007\uffca\012\uffca\013\uffca\014\uffca\016" +
    "\uffca\025\uffca\026\uffca\001\002\000\004\004\077\001\002" +
    "\000\024\004\070\006\061\010\075\012\064\013\060\014" +
    "\056\016\053\025\044\026\uffd1\001\002\000\004\026\uffd2" +
    "\001\002\000\004\004\076\001\002\000\010\027\uffed\030" +
    "\uffed\035\035\001\002\000\012\023\100\027\uffed\030\uffed" +
    "\035\035\001\002\000\006\004\105\020\104\001\002\000" +
    "\004\023\100\001\002\000\004\030\103\001\002\000\026" +
    "\004\ufff3\006\ufff3\010\ufff3\012\ufff3\013\ufff3\014\ufff3\015" +
    "\ufff3\016\ufff3\025\ufff3\026\ufff3\001\002\000\004\024\107" +
    "\001\002\000\004\024\106\001\002\000\006\023\ufff1\030" +
    "\ufff1\001\002\000\006\023\ufff2\030\ufff2\001\002\000\010" +
    "\004\147\020\130\021\131\001\002\000\010\004\132\020" +
    "\130\021\131\001\002\000\004\023\110\001\002\000\006" +
    "\004\117\022\115\001\002\000\020\022\uffb7\024\uffb7\030" +
    "\uffb7\031\uffb7\032\uffb7\033\uffb7\034\uffb7\001\002\000\020" +
    "\022\uffb6\024\uffb6\030\uffb6\031\uffb6\032\uffb6\033\uffb6\034" +
    "\uffb6\001\002\000\006\022\124\027\123\001\002\000\010" +
    "\022\uffb2\023\110\027\uffb2\001\002\000\006\022\uffb4\027" +
    "\uffb4\001\002\000\004\023\110\001\002\000\006\022\uffb1" +
    "\027\uffb1\001\002\000\004\004\117\001\002\000\020\022" +
    "\uffb5\024\uffb5\030\uffb5\031\uffb5\032\uffb5\033\uffb5\034\uffb5" +
    "\001\002\000\006\022\uffb3\027\uffb3\001\002\000\004\035" +
    "\127\001\002\000\010\004\132\020\130\021\131\001\002" +
    "\000\020\022\uffc2\024\uffc2\030\uffc2\031\uffc2\032\uffc2\033" +
    "\uffc2\034\uffc2\001\002\000\010\004\147\020\130\021\131" +
    "\001\002\000\024\021\113\022\uffc1\023\110\024\uffc1\030" +
    "\uffc1\031\uffc1\032\uffc1\033\uffc1\034\uffc1\001\002\000\020" +
    "\022\uffbf\024\uffbf\030\uffbf\031\uffbf\032\uffbf\033\uffbf\034" +
    "\uffbf\001\002\000\020\022\uffc3\024\uffc3\030\uffc3\031\135" +
    "\032\140\033\137\034\136\001\002\000\010\004\132\020" +
    "\130\021\131\001\002\000\010\004\132\020\130\021\131" +
    "\001\002\000\010\004\132\020\130\021\131\001\002\000" +
    "\010\004\132\020\130\021\131\001\002\000\020\022\uffbd" +
    "\024\uffbd\030\uffbd\031\135\032\uffbd\033\uffbd\034\uffbd\001" +
    "\002\000\020\022\uffbc\024\uffbc\030\uffbc\031\135\032\140" +
    "\033\uffbc\034\uffbc\001\002\000\020\022\uffbb\024\uffbb\030" +
    "\uffbb\031\135\032\140\033\137\034\uffbb\001\002\000\020" +
    "\022\uffbe\024\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\034" +
    "\uffbe\001\002\000\004\023\110\001\002\000\020\022\uffc0" +
    "\024\uffc0\030\uffc0\031\uffc0\032\uffc0\033\uffc0\034\uffc0\001" +
    "\002\000\026\021\113\022\uffc1\023\110\024\uffc1\030\uffc1" +
    "\031\uffc1\032\uffc1\033\uffc1\034\uffc1\035\111\001\002\000" +
    "\020\022\uffb9\024\uffb9\030\uffb9\031\135\032\140\033\137" +
    "\034\136\001\002\000\010\022\uffb8\024\uffb8\030\uffb8\001" +
    "\002\000\004\022\153\001\002\000\020\022\uffba\024\uffba" +
    "\030\uffba\031\uffba\032\uffba\033\uffba\034\uffba\001\002\000" +
    "\004\023\110\001\002\000\022\022\uffc0\024\uffc0\030\uffc0" +
    "\031\uffc0\032\uffc0\033\uffc0\034\uffc0\035\127\001\002\000" +
    "\020\022\uffc4\024\uffc4\030\uffc4\031\135\032\140\033\137" +
    "\034\136\001\002\000\004\024\160\001\002\000\026\022" +
    "\ufff0\023\ufff0\024\ufff0\027\ufff0\030\ufff0\031\ufff0\032\ufff0" +
    "\033\ufff0\034\ufff0\035\ufff0\001\002\000\024\004\uffc6\006" +
    "\uffc6\007\uffc6\012\uffc6\013\uffc6\014\uffc6\016\uffc6\025\uffc6" +
    "\026\uffc6\001\002\000\004\026\uffcc\001\002\000\010\021" +
    "\113\023\110\035\111\001\002\000\004\017\165\001\002" +
    "\000\004\022\166\001\002\000\004\030\167\001\002\000" +
    "\024\004\uffa6\006\uffa6\007\uffa6\012\uffa6\013\uffa6\014\uffa6" +
    "\016\uffa6\025\uffa6\026\uffa6\001\002\000\032\002\uffd7\004" +
    "\uffd7\006\uffd7\007\uffd7\010\uffd7\012\uffd7\013\uffd7\014\uffd7" +
    "\015\uffd7\016\uffd7\025\uffd7\026\uffd7\001\002\000\024\004" +
    "\uffc7\006\uffc7\007\uffc7\012\uffc7\013\uffc7\014\uffc7\016\uffc7" +
    "\025\uffc7\026\uffc7\001\002\000\010\004\147\020\130\021" +
    "\131\001\002\000\004\022\174\001\002\000\020\004\163" +
    "\006\061\012\064\013\060\014\056\016\053\025\044\001" +
    "\002\000\024\004\uffb0\006\uffb0\007\202\012\uffb0\013\uffb0" +
    "\014\uffb0\016\uffb0\025\uffb0\026\uffb0\001\002\000\024\004" +
    "\uffaf\006\uffaf\007\177\012\uffaf\013\uffaf\014\uffaf\016\uffaf" +
    "\025\uffaf\026\uffaf\001\002\000\020\004\163\006\061\012" +
    "\064\013\060\014\056\016\053\025\044\001\002\000\024" +
    "\004\uffac\006\uffac\007\uffac\012\uffac\013\uffac\014\uffac\016" +
    "\uffac\025\uffac\026\uffac\001\002\000\024\004\uffab\006\uffab" +
    "\007\uffab\012\uffab\013\uffab\014\uffab\016\uffab\025\uffab\026" +
    "\uffab\001\002\000\020\004\163\006\061\012\064\013\060" +
    "\014\056\016\053\025\044\001\002\000\024\004\uffae\006" +
    "\uffae\007\uffae\012\uffae\013\uffae\014\uffae\016\uffae\025\uffae" +
    "\026\uffae\001\002\000\024\004\uffad\006\uffad\007\uffad\012" +
    "\uffad\013\uffad\014\uffad\016\uffad\025\uffad\026\uffad\001\002" +
    "\000\012\004\147\020\130\021\131\022\206\001\002\000" +
    "\004\030\212\001\002\000\004\022\210\001\002\000\004" +
    "\030\211\001\002\000\024\004\uffa8\006\uffa8\007\uffa8\012" +
    "\uffa8\013\uffa8\014\uffa8\016\uffa8\025\uffa8\026\uffa8\001\002" +
    "\000\024\004\uffa7\006\uffa7\007\uffa7\012\uffa7\013\uffa7\014" +
    "\uffa7\016\uffa7\025\uffa7\026\uffa7\001\002\000\024\004\uffa4" +
    "\006\uffa4\007\uffa4\012\uffa4\013\uffa4\014\uffa4\016\uffa4\025" +
    "\uffa4\026\uffa4\001\002\000\004\030\215\001\002\000\024" +
    "\004\uffa5\006\uffa5\007\uffa5\012\uffa5\013\uffa5\014\uffa5\016" +
    "\uffa5\025\uffa5\026\uffa5\001\002\000\004\026\uffce\001\002" +
    "\000\010\004\147\020\130\021\131\001\002\000\004\022" +
    "\221\001\002\000\020\004\163\006\061\012\064\013\060" +
    "\014\056\016\053\025\044\001\002\000\024\004\uffaa\006" +
    "\uffaa\007\uffaa\012\uffaa\013\uffaa\014\uffaa\016\uffaa\025\uffaa" +
    "\026\uffaa\001\002\000\024\004\uffa9\006\uffa9\007\uffa9\012" +
    "\uffa9\013\uffa9\014\uffa9\016\uffa9\025\uffa9\026\uffa9\001\002" +
    "\000\004\026\uffd5\001\002\000\004\025\uffde\001\002\000" +
    "\004\036\uffd9\001\002\000\004\036\237\001\002\000\006" +
    "\022\233\027\232\001\002\000\004\036\uffda\001\002\000" +
    "\006\004\226\010\231\001\002\000\004\025\uffdd\001\002" +
    "\000\004\036\235\001\002\000\004\004\236\001\002\000" +
    "\006\022\uffdb\027\uffdb\001\002\000\004\004\240\001\002" +
    "\000\006\022\uffdc\027\uffdc\001\002\000\004\002\ufff6\001" +
    "\002\000\004\004\243\001\002\000\004\021\uffe5\001\002" +
    "\000\004\004\246\001\002\000\026\004\uffef\006\uffef\010" +
    "\uffef\012\uffef\013\uffef\014\uffef\015\uffef\016\uffef\025\uffef" +
    "\026\uffef\001\002\000\010\027\uffea\030\uffea\035\247\001" +
    "\002\000\006\004\251\020\250\001\002\000\006\027\uffe9" +
    "\030\uffe9\001\002\000\006\027\uffe8\030\uffe8\001\002\000" +
    "\004\004\254\001\002\000\026\004\uffee\006\uffee\010\uffee" +
    "\012\uffee\013\uffee\014\uffee\015\uffee\016\uffee\025\uffee\026" +
    "\uffee\001\002\000\006\027\uffe6\030\uffe6\001\002\000\004" +
    "\021\uffe2\001\002\000\004\021\257\001\002\000\004\022" +
    "\260\001\002\000\004\025\044\001\002\000\004\002\uffdf" +
    "\001\002\000\004\021\040\001\002\000\004\025\uffe1\001" +
    "\002\000\004\025\044\001\002\000\006\010\uffe0\015\uffe0" +
    "\001\002\000\014\021\uffe5\023\100\027\uffed\030\uffed\035" +
    "\035\001\002\000\004\002\ufffc\001\002\000\004\020\271" +
    "\001\002\000\004\030\272\001\002\000\012\004\ufff4\005" +
    "\ufff4\010\ufff4\015\ufff4\001\002\000\004\002\001\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\271\000\006\002\003\046\004\001\001\000\002\001" +
    "\001\000\006\045\006\047\005\001\001\000\030\003\023" +
    "\004\017\005\013\006\021\007\016\010\010\012\025\014" +
    "\022\017\015\020\014\021\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\030\003\266\004\017\005\013\006" +
    "\021\007\016\010\010\012\025\014\022\017\015\020\014" +
    "\021\020\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\006\240\007\016\021" +
    "\020\001\001\000\002\001\001\000\020\005\031\006\021" +
    "\007\016\014\022\017\015\020\014\021\020\001\001\000" +
    "\002\001\001\000\002\001\001\000\024\004\026\005\013" +
    "\006\021\007\016\012\025\014\022\017\015\020\014\021" +
    "\020\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\050\033\001\001\000" +
    "\004\023\040\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\022\226\024\227\001\001\000" +
    "\004\051\041\001\001\000\004\035\042\001\001\000\002" +
    "\001\001\000\044\011\056\012\047\013\045\014\072\017" +
    "\015\020\014\026\061\030\066\034\046\035\054\036\062" +
    "\037\050\040\064\041\053\042\070\043\044\044\051\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\042\011\223\012\047\013\045\014\072\017\015\020" +
    "\014\026\061\030\066\034\046\035\054\037\050\040\064" +
    "\041\053\042\070\043\044\044\051\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\026\026\061\030\066\034\046\035\054\037\215\040" +
    "\064\041\053\042\070\043\044\044\051\001\001\000\012" +
    "\025\213\026\150\027\147\030\132\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\026\026\061\030" +
    "\066\034\046\035\054\037\161\040\064\041\053\042\070" +
    "\043\044\044\051\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\016\111\031\113\001\001\000\002\001\001" +
    "\000\002\001\001\000\036\013\073\014\072\017\015\020" +
    "\014\026\061\030\066\034\046\035\054\037\050\040\064" +
    "\041\053\042\070\043\044\044\051\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\015\100" +
    "\001\001\000\002\001\001\000\004\015\101\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\025" +
    "\156\026\150\027\147\030\132\001\001\000\006\027\155" +
    "\030\132\001\001\000\004\016\125\001\001\000\006\032" +
    "\115\033\117\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\016\120\001\001\000\002\001" +
    "\001\000\004\016\121\001\001\000\002\001\001\000\004" +
    "\033\124\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\027\133\030\132\001\001\000\002" +
    "\001\001\000\012\025\151\026\150\027\147\030\132\001" +
    "\001\000\006\016\144\031\113\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\027\143\030\132\001\001\000" +
    "\006\027\142\030\132\001\001\000\006\027\141\030\132" +
    "\001\001\000\006\027\140\030\132\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\016\145\001\001\000\002\001\001\000\006\016" +
    "\153\031\113\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\016\154\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\016\111\031\113\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\025\172\026\150\027\147" +
    "\030\132\001\001\000\002\001\001\000\024\026\061\030" +
    "\066\034\046\035\175\040\174\041\053\042\070\043\044" +
    "\044\051\001\001\000\002\001\001\000\002\001\001\000" +
    "\024\026\061\030\066\034\046\035\200\040\177\041\053" +
    "\042\070\043\044\044\051\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\026\061\030\066\034\046\035\203" +
    "\040\202\041\053\042\070\043\044\044\051\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\025\206\026\150" +
    "\027\147\030\132\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\025\217\026\150\027\147\030\132" +
    "\001\001\000\002\001\001\000\024\026\061\030\066\034" +
    "\046\035\222\040\221\041\053\042\070\043\044\044\051" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\022\233\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\050\033\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\052" +
    "\261\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\035\260\001\001\000\002\001\001\000\004\023\262\001" +
    "\001\000\004\053\263\001\001\000\004\035\264\001\001" +
    "\000\002\001\001\000\006\015\100\050\033\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}




	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();

	public void syntax_error(Symbol symbol)
	{

	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);
	}

	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);

	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {



    //comprobar que no son arrays en asignaciones, if, while etc

	SyntaxErrorManager        syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager      semanticErrorManager = CompilerContext.getSemanticErrorManager();
	ScopeManagerIF            scopeManager         = CompilerContext.getScopeManager();
	FinalCodeFactoryIF        finalCodeFactory     = CompilerContext.getFinalCodeFactory();

    public void checkFunctionCallParamsSize(String functionName, int size){
       SymbolIF functionSymbol = scopeManager.searchSymbol(functionName);
       if (functionSymbol instanceof SymbolFunction) {
          SymbolFunction functionSymbolCasted = (SymbolFunction) functionSymbol;
         if (functionSymbolCasted.getParameters().size() != size){
           semanticErrorManager.semanticFatalError(String.format("Call to %s does not match params size", functionName));
         }
       } else {
         semanticErrorManager.semanticFatalError(String.format("%s is not a function", functionName));
       }
    }

    public void checkSymbolDoesNotExists(String name){
       ScopeIF scope = scopeManager.getCurrentScope();
       SymbolTableIF symbolTable = scope.getSymbolTable();
       if (symbolTable.containsSymbol(name)) {
         semanticErrorManager.semanticFatalError(String.format("Element %s already exists in scope", name));
       }
    }

    public void checkSymbolExists(String name){
      boolean found = scopeManager.getCurrentScope().getSymbolTable().containsSymbol(name) ||
       scopeManager.searchSymbol(name).getScope().getName().equals("global");

      if (!found) {
        semanticErrorManager.semanticFatalError(String.format("Element %s does not exist in scope", name));
      }
    }

    public void checkFunctionExists(String name){
       ScopeIF scope = scopeManager.getCurrentScope();
       SymbolTableIF symbolTable = scope.getSymbolTable();
       if (!symbolTable.containsSymbol(name)) {
        semanticErrorManager.semanticFatalError(String.format("Element %s does not exists in scope, cannot be called", name));
       }
    }

     public void checkFunctionDoesNotExists(String name){
       ScopeIF scope = scopeManager.getCurrentScope();
       SymbolTableIF symbolTable = scope.getSymbolTable();
       if (symbolTable.getSymbol(name) != null && symbolTable.getSymbol(name) instanceof SymbolFunction) {
          semanticErrorManager.semanticFatalError(String.format("Function %s already exists in scope", name));
       }
     }

     public TypeIF getType(String name) {
         if (!scopeManager.containsType(name)){
               semanticErrorManager.semanticFatalError(String.format("Type %s does not exists", name));
         }
         return scopeManager.searchType(name);
     }

     public SymbolIF getSymbol(String name){

         if (!scopeManager.containsSymbol(name)){
              semanticErrorManager.semanticFatalError(String.format("Symbol %s does not exists", name));
         }
         return scopeManager.searchSymbol(name);
     }

    public boolean checkParamsAreNotDuplicated(String name, List<TemporalParam> params) {
        boolean paramsDuplicated = params
                .stream()
                .collect(java.util.stream.Collectors.groupingBy(TemporalParam::getName))
                .values()
                .stream()
                .anyMatch(temporalParams -> temporalParams.size() > 1);
                if (paramsDuplicated) {
                    semanticErrorManager.semanticFatalError(String.format("Function %s has multiple params with same name", name));
                }
        return false;
    }

    public boolean checkSymbolIsNotArray(String name){
        ScopeIF scope = scopeManager.getCurrentScope();
        SymbolTableIF symbolTable = scope.getSymbolTable();
        if (symbolTable.getSymbol(name) == null) {
           semanticErrorManager.semanticFatalError(String.format("Symbol %s does not exists", name));
        }

        SymbolVariable variable = (SymbolVariable) symbolTable.getSymbol(name);
        TypeIF variableType = variable.getType();
        if (variableType.getName().equals("array")){
           semanticErrorManager.semanticFatalError(String.format("Cannot assign variable to array", name));
        }
        return true;
    }

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // retorno_funcion ::= RETURN PUNTOYCOMA 
            {
              AbstractReturn RESULT =null;
		
                         RESULT = new VoidReturn();
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // retorno_funcion ::= RETURN expresion PUNTOYCOMA 
            {
              AbstractReturn RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                        RESULT = new ExpressionReturn(expr);
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("retorno_funcion",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // sentencia_printc ::= PRINTC PARIZQ CADENA PARDER PUNTOYCOMA 
            {
              PrintCSentence RESULT =null;
		int sentenceleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentenceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token sentence = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                            RESULT = new PrintCSentence(sentence.getLexema());
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printc",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentencia_printi ::= PRINTI PARIZQ PARDER PUNTOYCOMA 
            {
              PrintISentence RESULT =null;
		
						    RESULT = new PrintISentence();
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentencia_printi ::= PRINTI PARIZQ expresion PARDER PUNTOYCOMA 
            {
              PrintISentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
 						   RESULT = new PrintISentence(expr);
 						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_printi",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentencia_while ::= WHILE PARIZQ expresion PARDER bloque_sentencias 
            {
              WhileSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                      if(!expr.getReturnType().getName().equals("boolean")){
                            semanticErrorManager.semanticFatalError("While expresion should be boolean");
                      }
                       if(expr.getIdentifier()!=null){
                         SymbolIF symbol = getSymbol(expr.getIdentifier());
                         if(symbol.getType().getName().equals("array")){
                             if(expr.getTo()==null||expr.getFrom()==null){
                               semanticErrorManager.semanticFatalError("While should use boolean expresion not arrays");
                             }
                         }
                       }
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentencia_while ::= WHILE PARIZQ expresion PARDER sentencia 
            {
              WhileSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                      if(!expr.getReturnType().getName().equals("boolean")){
                            semanticErrorManager.semanticFatalError("While expresion should be boolean");
                      }
                       if(expr.getIdentifier()!=null){
                         SymbolIF symbol = getSymbol(expr.getIdentifier());
                         if(symbol.getType().getName().equals("array")){
                             if(expr.getTo()==null||expr.getFrom()==null){
                               semanticErrorManager.semanticFatalError("While should use boolean expresion not arrays");
                             }
                         }
                       }
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_while",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE bloque_sentencias 
            {
              IfSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
                    if(!expr.getReturnType().getName().equals("boolean")){
                        semanticErrorManager.semanticFatalError("Expresion should be boolean");
                    }
                       if(expr.getIdentifier()!=null){
                         SymbolIF symbol = getSymbol(expr.getIdentifier());
                         if(symbol.getType().getName().equals("array")){
                             if(expr.getTo()==null||expr.getFrom()==null){
                               semanticErrorManager.semanticFatalError("If should use boolean expresion not arrays");
                             }
                         }
                       }
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias ELSE sentencia 
            {
              IfSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
					  if(!expr.getReturnType().getName().equals("boolean")){
                        semanticErrorManager.semanticFatalError("Expresion should be boolean");
                      }
                      if(expr.getIdentifier()!=null){
                        SymbolIF symbol = getSymbol(expr.getIdentifier());
                        if(symbol.getType().getName().equals("array")){
                            if(expr.getTo()==null||expr.getFrom()==null){
                              semanticErrorManager.semanticFatalError("If should use boolean expresion not arrays");
                            }
                        }
                      }
					  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE bloque_sentencias 
            {
              IfSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
					if(!expr.getReturnType().getName().equals("boolean")){
                        semanticErrorManager.semanticFatalError("Expresion should be boolean");
                    }
                      if(expr.getIdentifier()!=null){
                        SymbolIF symbol = getSymbol(expr.getIdentifier());
                        if(symbol.getType().getName().equals("array")){
                            if(expr.getTo()==null||expr.getFrom()==null){
                              semanticErrorManager.semanticFatalError("If should use boolean expresion not arrays");
                            }
                        }
                      }
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia ELSE sentencia 
            {
              IfSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
					  if(!expr.getReturnType().getName().equals("boolean")){
                        semanticErrorManager.semanticFatalError("Expresion should be boolean");
                      }
                      if(expr.getIdentifier()!=null){
                        SymbolIF symbol = getSymbol(expr.getIdentifier());
                        if(symbol.getType().getName().equals("array")){
                            if(expr.getTo()==null||expr.getFrom()==null){
                              semanticErrorManager.semanticFatalError("If should use boolean expresion not arrays");
                            }
                        }
                      }
					  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentencia_if ::= IF PARIZQ expresion PARDER bloque_sentencias 
            {
              IfSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                      if(!expr.getReturnType().getName().equals("boolean")){
                        semanticErrorManager.semanticFatalError("Expresion should be boolean");
                      }

                      if(expr.getIdentifier()!=null){
                        SymbolIF symbol = getSymbol(expr.getIdentifier());
                        if(symbol.getType().getName().equals("array")){
                            if(expr.getTo()==null||expr.getFrom()==null){
                              semanticErrorManager.semanticFatalError("If should use boolean expresion not arrays");
                            }
                        }
                      }

					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentencia_if ::= IF PARIZQ expresion PARDER sentencia 
            {
              IfSentence RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
                        if(!expr.getReturnType().getName().equals("boolean")){
                          semanticErrorManager.semanticFatalError("Cannot use array here");
                        }

                        if(expr.getIdentifier()!=null){
                          SymbolIF symbol = getSymbol(expr.getIdentifier());
                          if(symbol.getType().getName().equals("array")){
                              if(expr.getTo()==null||expr.getFrom()==null){
                                semanticErrorManager.semanticFatalError("If should use boolean expresion not arrays");
                              }
                          }
                        }

  					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia_if",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // parametro ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Parameter RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int startRangeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int startRangeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayRange startRange = (ArrayRange)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int endRangeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int endRangeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayRange endRange = (ArrayRange)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    RESULT = new Parameter(name.getLexema(), startRange, endRange);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // parametro ::= IDENTIFICADOR 
            {
              Parameter RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    RESULT = new Parameter(name.getLexema(), null, null);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametro",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // parametros ::= parametros COMA parametro 
            {
              List<Parameter> RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<Parameter> params = (List<Parameter>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Parameter param = (Parameter)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				 params.add(param);
				 RESULT = params;
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // parametros ::= parametro 
            {
              List<Parameter> RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Parameter param = (Parameter)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    List<Parameter> params = new ArrayList();
                    params.add(param);
                    RESULT = params;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // lista_parametros ::= PARIZQ parametros PARDER 
            {
              ParametersList RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<Parameter> params = (List<Parameter>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
					   RESULT = new ParametersList(params);
					 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // lista_parametros ::= PARIZQ PARDER 
            {
              ParametersList RESULT =null;
		
                            RESULT = new ParametersList(new ArrayList());
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_parametros",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // llamada_funcion ::= IDENTIFICADOR lista_parametros 
            {
              CallFunction RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ParametersList params = (ParametersList)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        checkFunctionExists(name.getLexema());
                        checkFunctionCallParamsSize(name.getLexema(), params.getParams().size());

                        for (Parameter callParam : params.getParams()){
                          checkSymbolExists(callParam.getName());
                        }

                        RESULT = new CallFunction(name.getLexema(), params);
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("llamada_funcion",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // expresion ::= asignacion 
            {
              Expression RESULT =null;
		int asigleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int asigright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Assignation asig = (Assignation)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                RESULT = new Expression(asig, asig.getReturnType());
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // expresion ::= expresion_sin_asign 
            {
              Expression RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    RESULT = expr;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // expresion_sin_asign ::= PARIZQ expresion PARDER 
            {
              Expression RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						     checkSymbolExists(expr.getIdentifier());
						     if(expr.isAssignation()){
						       semanticErrorManager.semanticFatalError("Assisgnation are not allowed here");
						     }
                             RESULT = new Expression(expr, expr.getReturnType());
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // expresion_sin_asign ::= expresion_sin_asign AND expresion_sin_asign 
            {
              Expression RESULT =null;
		int leftExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression leftExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expression rightExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						    if(leftExpr.getIdentifier()!=null){
                                checkSymbolExists(leftExpr.getIdentifier());
                            }
                            if(rightExpr.getIdentifier()!=null){
                                checkSymbolExists(rightExpr.getIdentifier());
                            }

                            if(!leftExpr.getReturnType().getName().equals("boolean")){
                             semanticErrorManager.semanticFatalError("LeftExpresion should be a boolean");
                            }
                            if(!rightExpr.getReturnType().getName().equals("boolean")){
                             semanticErrorManager.semanticFatalError("LeftExpresion should be a boolean");
                            }

                          RESULT = new Expression(leftExpr, rightExpr, getType("boolean"));
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // expresion_sin_asign ::= expresion_sin_asign DISTINTO expresion_sin_asign 
            {
              Expression RESULT =null;
		int leftExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression leftExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expression rightExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						   if(leftExpr.getIdentifier()!=null){
                                checkSymbolExists(leftExpr.getIdentifier());
                           }
                           if(rightExpr.getIdentifier()!=null){
                                checkSymbolExists(rightExpr.getIdentifier());
                           }

                           if(!leftExpr.getReturnType().getName().equals("int")){
                             semanticErrorManager.semanticFatalError("LeftExpresion should be an int");
                           }

                           if(!rightExpr.getReturnType().getName().equals("int")){
                            semanticErrorManager.semanticFatalError("LeftExpresion should be an int");
                           }

                            RESULT = new Expression(leftExpr, rightExpr, getType("boolean"));
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // expresion_sin_asign ::= expresion_sin_asign MENOR expresion_sin_asign 
            {
              Expression RESULT =null;
		int leftExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression leftExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expression rightExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						    if(leftExpr.getIdentifier()!=null){
                        	    checkSymbolExists(leftExpr.getIdentifier());
                            }
                        	if(rightExpr.getIdentifier()!=null){
                                checkSymbolExists(rightExpr.getIdentifier());
                            }
                           if(!leftExpr.getReturnType().getName().equals("int")){
                             semanticErrorManager.semanticFatalError("LeftExpresion should be a int");
                           }

                           if(!rightExpr.getReturnType().getName().equals("int")){
                            semanticErrorManager.semanticFatalError("LeftExpresion should be a int");
                           }

                            RESULT = new Expression(leftExpr, rightExpr, getType("boolean"));
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // expresion_sin_asign ::= expresion_sin_asign MAS expresion_sin_asign 
            {
              Expression RESULT =null;
		int leftExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int leftExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expression leftExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rightExprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rightExprright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expression rightExpr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						    if(leftExpr.getIdentifier()!=null){
						    	checkSymbolExists(leftExpr.getIdentifier());
						    }
						    if(rightExpr.getIdentifier()!=null){
                                checkSymbolExists(rightExpr.getIdentifier());
                            }
                           if(!leftExpr.getReturnType().getName().equals("int")){
                             semanticErrorManager.semanticFatalError("LeftExpresion should be an int");
                           }

                           if(!rightExpr.getReturnType().getName().equals("int")){
                            semanticErrorManager.semanticFatalError("LeftExpresion should be an int");
                           }

                            RESULT = new Expression(leftExpr, rightExpr, getType("int"));
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // expresion_sin_asign ::= llamada_funcion 
            {
              Expression RESULT =null;
		int functionCallleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int functionCallright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CallFunction functionCall = (CallFunction)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						    SymbolFunction functionSymbol = (SymbolFunction) getSymbol(functionCall.getName());
                            RESULT = new Expression(functionCall, functionSymbol.getReturnType());
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // expresion_sin_asign ::= IDENTIFICADOR rango_matriz rango_matriz 
            {
              Expression RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int fromleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fromright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayRange from = (ArrayRange)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int toleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int toright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ArrayRange to = (ArrayRange)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                            RESULT = new Expression(name.getLexema(), from, to, getType("int"));
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // expresion_sin_asign ::= IDENTIFICADOR 
            {
              Expression RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                            RESULT = new Expression(name.getLexema(), getType("int"));
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // expresion_sin_asign ::= NUMERO 
            {
              Expression RESULT =null;
		int numberleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numberright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token number = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                            RESULT = new Expression(Integer.parseInt(number.getLexema()), getType("int"));
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion_sin_asign",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // asignacion ::= IDENTIFICADOR rango_matriz rango_matriz ASIGNACION expresion_sin_asign 
            {
              Assignation RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int leftRangeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int leftRangeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		ArrayRange leftRange = (ArrayRange)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int rightRangeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rightRangeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ArrayRange rightRange = (ArrayRange)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valueToAsignleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valueToAsignright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expression valueToAsign = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
 				     checkSymbolDoesNotExists(name.getLexema());
 				     RESULT = new Assignation(name.getLexema(),leftRange,rightRange, valueToAsign);
 				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // asignacion ::= IDENTIFICADOR ASIGNACION expresion_sin_asign 
            {
              Assignation RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valueToAsignleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valueToAsignright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expression valueToAsign = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    checkSymbolDoesNotExists(name.getLexema());
                    if(valueToAsign.getIdentifier()!=null){
                      SymbolIF symbol = getSymbol(valueToAsign.getIdentifier());
                    }
                    RESULT = new Assignation(name.getLexema(), valueToAsign);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("asignacion",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentencia ::= retorno_funcion 
            {
              AbstractSentence RESULT =null;
		int returnFunctionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int returnFunctionright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AbstractReturn returnFunction = (AbstractReturn)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                if (returnFunction instanceof VoidReturn) {
                    RESULT = new ReturnEmptySentence();
                } else {
                    RESULT = new ReturnExpressionSentence(returnFunction);
                }
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // sentencia ::= llamada_funcion PUNTOYCOMA 
            {
              AbstractSentence RESULT =null;
		int callFunctionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int callFunctionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CallFunction callFunction = (CallFunction)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
			    //callFunction is CallFunction
			    RESULT = callFunction;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // sentencia ::= asignacion PUNTOYCOMA 
            {
              AbstractSentence RESULT =null;
		int asigleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int asigright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Assignation asig = (Assignation)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                RESULT=asig;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // sentencia ::= sentencia_printc 
            {
              AbstractSentence RESULT =null;
		int printcleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int printcright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		PrintCSentence printc = (PrintCSentence)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
              	RESULT=printc;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // sentencia ::= sentencia_printi 
            {
              AbstractSentence RESULT =null;
		int printileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int printiright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		PrintISentence printi = (PrintISentence)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    RESULT=printi;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // sentencia ::= sentencia_while 
            {
              AbstractSentence RESULT =null;
		
              RESULT=new WhileSentence();
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // sentencia ::= sentencia_if 
            {
              AbstractSentence RESULT =null;
		
  			    RESULT=new IfSentence();
  			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // sentencias ::= sentencia sentencias 
            {
              Sentences RESULT =null;
		int sentenceleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentenceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AbstractSentence sentence = (AbstractSentence)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentencesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentences sentences = (Sentences)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			  //sentence is AbstractSentence
              //sentences is Sentencnes
			    sentences.add(sentence);
			    RESULT=sentences;
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // sentencias ::= sentencia 
            {
              Sentences RESULT =null;
		int sentenceleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentenceright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AbstractSentence sentence = (AbstractSentence)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			  	//sentence is AbstractSentence
                RESULT = new Sentences(sentence);
			  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // sentencias ::= bloque_sentencias sentencias 
            {
              Sentences RESULT =null;
		int sentencesBlockleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentencesBlockright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		BlockSentences sentencesBlock = (BlockSentences)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentencesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentences sentences = (Sentences)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			    //sentencesBlock is BlockSentences
			    //sentences is Sentencnes
			    sentences.add(sentencesBlock);
                RESULT = sentences;
			 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // sentencias ::= bloque_sentencias 
            {
              Sentences RESULT =null;
		int sentencesBlockleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesBlockright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BlockSentences sentencesBlock = (BlockSentences)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                //sentencesBlock is BlockSentences
                RESULT = new Sentences(sentencesBlock);
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // declar_variables ::= sentencias 
            {
              VariableDeclarations RESULT =null;
		int blockSentencesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int blockSentencesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentences blockSentences = (Sentences)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                            RESULT = new VariableDeclarations(Collections.emptyList(), blockSentences);
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // declar_variables ::= declar_variable 
            {
              VariableDeclarations RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VariableDeclaration var = (VariableDeclaration)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                           RESULT = new VariableDeclarations(Collections.singletonList(var), null);
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // declar_variables ::= declar_variable declar_variables 
            {
              VariableDeclarations RESULT =null;
		int varleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int varright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		VariableDeclaration var = (VariableDeclaration)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int varsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VariableDeclarations vars = (VariableDeclarations)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                            vars.addVar(var);
                            RESULT = vars;
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // declar_tipos ::= declar_variables 
            {
              TypesDeclaration RESULT =null;
		int varDeclarationleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varDeclarationright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VariableDeclarations varDeclaration = (VariableDeclarations)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        //varDeclaration is VarDeclarations
                        RESULT = new TypesDeclaration(varDeclaration);
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // declar_tipos ::= declar_tipo 
            {
              TypesDeclaration RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Array type = (Array)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        //type is array
                        RESULT = new TypesDeclaration(Collections.singletonList(type));
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // declar_tipos ::= declar_tipo declar_tipos 
            {
              TypesDeclaration RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Array type = (Array)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int typesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		TypesDeclaration types = (TypesDeclaration)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        //types is TypesDeclaration
                        //type is Array
                        types.addType(type);
                        RESULT = types;
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // cuerpo_sentencias ::= declar_tipos 
            {
              TypesDeclaration RESULT =null;
		int typesDeclarationleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int typesDeclarationright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		TypesDeclaration typesDeclaration = (TypesDeclaration)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                            //typesDeclaration is TypesDeclaration
                            RESULT = typesDeclaration;
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo_sentencias",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // bloque_sentencias ::= LLAVEIZQ cuerpo_sentencias LLAVEDER 
            {
              BlockSentences RESULT =null;
		int sentencesBodyleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentencesBodyright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		TypesDeclaration sentencesBody = (TypesDeclaration)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
	                        //sentencesBody is TypesDeclaration
                            RESULT = new BlockSentences(sentencesBody);
	                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // bloque_sentencias ::= LLAVEIZQ LLAVEDER 
            {
              BlockSentences RESULT =null;
		
                            RESULT = new BlockSentences();
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("bloque_sentencias",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // tipo_parametros ::= IDENTIFICADOR 
            {
              TypeIF RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                        SymbolIF symbol = getSymbol(name.getLexema());
                        RESULT = symbol.getType();
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // tipo_parametros ::= ENTERO 
            {
              TypeIF RESULT =null;
		
                       TypeIF paramsType = getType("int");
                       RESULT = paramsType;
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo_parametros",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // lista_declar_parametros ::= lista_declar_parametros COMA tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              List<TemporalParam> RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		List<TemporalParam> params = (List<TemporalParam>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int paramTypeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paramTyperight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		TypeIF paramType = (TypeIF)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                    TypeIF paramsType = getType(paramType.getName());
                                    params.add(new TemporalParam(name.getLexema(), paramsType));
                                    RESULT = params;
                                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // lista_declar_parametros ::= tipo_parametros REFERENCIA IDENTIFICADOR 
            {
              List<TemporalParam> RESULT =null;
		int paramTypeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paramTyperight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		TypeIF paramType = (TypeIF)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                    TypeIF paramsType = getType(paramType.getName());
                                    TemporalParam temporalParam = new TemporalParam(name.getLexema(), paramsType);
                                    List<TemporalParam> params = new ArrayList<>();
                                    params.add(temporalParam);
                                    RESULT = params;
                                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_declar_parametros",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // declar_parametros ::= PARIZQ lista_declar_parametros PARDER 
            {
              List<TemporalParam> RESULT =null;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<TemporalParam> params = (List<TemporalParam>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
					        RESULT = params;
					   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // declar_parametros ::= PARIZQ PARDER 
            {
              List<TemporalParam> RESULT =null;
		
                            RESULT = Collections.EMPTY_LIST;
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_parametros",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // declar_main ::= VOID MAIN PARIZQ PARDER bloque_sentencias 
            {
              Object RESULT =null;
		int sentencesBlockleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesBlockright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BlockSentences sentencesBlock = (BlockSentences)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    checkFunctionDoesNotExists("main");
                    ScopeIF scope = scopeManager.getCurrentScope();
                    SymbolTableIF symbolTable = scope.getSymbolTable();
                    SymbolFunction symbolFunction = new SymbolFunction(scope, "main", getType("void"), Collections.emptyList(), null);
                    symbolTable.addSymbol(symbolFunction);
                    System.out.println("Detected main function");
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_main",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // declar_funcion ::= VOID IDENTIFICADOR NT$4 declar_parametros NT$5 bloque_sentencias 
            {
              SymbolFunction RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (SymbolFunction) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<TemporalParam> params = (List<TemporalParam>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentencesBlockleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesBlockright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BlockSentences sentencesBlock = (BlockSentences)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                               //params is List<TemporalParam>
                                               //sentencesBlock is BlockSentences

                                               scopeManager.closeScope();
                                               ScopeIF globalScope = scopeManager.getCurrentScope();
                                               SymbolTableIF globalSymbolTable =  globalScope.getSymbolTable();
                                               List<SymbolParameter> functionParams = new ArrayList();
                                               for (TemporalParam temporalParam : params) {
                                                 functionParams.add(new SymbolParameter(scopeManager.getCurrentScope(), temporalParam.getName(), temporalParam.getType()));
                                               }
                                               SymbolFunction symbolFunction = new SymbolFunction(globalScope, name.getLexema(), getType("void"), functionParams, sentencesBlock);
                                               globalSymbolTable.addSymbol(symbolFunction);
                                               RESULT=symbolFunction;
                                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // NT$5 ::= 
            {
              SymbolFunction RESULT =(SymbolFunction) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<TemporalParam> params = (List<TemporalParam>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                                            checkParamsAreNotDuplicated(name.getLexema(), params);
                                            ScopeIF functionScope = scopeManager.searchScope(name.getLexema());
                                            System.out.print(String.format("Function declared with name %s return type %s and params:", name.getLexema(), "void"));
                                            for (TemporalParam temporalParam : params) {
                                                System.out.print(temporalParam.getName());
                                                System.out.print(",");
                                            }
                                            System.out.println();
                                            SymbolTableIF functionSymbolTable = functionScope.getSymbolTable();
                                            for (TemporalParam temporalParam : params) {
                                                functionSymbolTable.addSymbol(new SymbolVariable<String>(functionScope, temporalParam.getName(), temporalParam.getType()));
                                            }
                                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // NT$4 ::= 
            {
              SymbolFunction RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                                       checkFunctionDoesNotExists(name.getLexema());
                                       String functionName = name.getLexema();
                                       ScopeIF functionScope = scopeManager.openScope(functionName);
                                       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // declar_funcion ::= ENTERO IDENTIFICADOR NT$2 declar_parametros NT$3 bloque_sentencias 
            {
              SymbolFunction RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (SymbolFunction) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<TemporalParam> params = (List<TemporalParam>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentencesBlockleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesBlockright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BlockSentences sentencesBlock = (BlockSentences)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                           //params is List<TemporalParam>
                           //sentencesBlock is BlockSentences

                           scopeManager.closeScope();
                           ScopeIF globalScope = scopeManager.getCurrentScope();
                           SymbolTableIF globalSymbolTable =  globalScope.getSymbolTable();
                           List<SymbolParameter> functionParams = new ArrayList();
                           for (TemporalParam temporalParam : params) {
                             functionParams.add(new SymbolParameter(scopeManager.getCurrentScope(), temporalParam.getName(), temporalParam.getType()));
                           }
                           SymbolFunction symbolFunction = new SymbolFunction(globalScope, name.getLexema(), getType("int"), functionParams, sentencesBlock);
                           globalSymbolTable.addSymbol(symbolFunction);
                           RESULT=symbolFunction;
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funcion",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$3 ::= 
            {
              SymbolFunction RESULT =(SymbolFunction) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<TemporalParam> params = (List<TemporalParam>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                        checkParamsAreNotDuplicated(name.getLexema(), params);
                        ScopeIF functionScope = scopeManager.searchScope(name.getLexema());
                        System.out.print(String.format("Function declared with name %s return type %s and params:", name.getLexema(), "int"));
                        for (TemporalParam temporalParam : params) {
                            System.out.print(temporalParam.getName());
                            System.out.print(",");
                        }
                        System.out.println();
                        SymbolTableIF functionSymbolTable = functionScope.getSymbolTable();
                        for (TemporalParam temporalParam : params) {
                            functionSymbolTable.addSymbol(new SymbolVariable<String>(functionScope, temporalParam.getName(), temporalParam.getType()));
                        }
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // NT$2 ::= 
            {
              SymbolFunction RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                                               checkFunctionDoesNotExists(name.getLexema());
                                               String functionName = name.getLexema();
                                               ScopeIF functionScope = scopeManager.openScope(functionName);
                                             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // lista_variables_matriz ::= lista_variables_matriz COMA IDENTIFICADOR 
            {
              List<GenericVariable> RESULT =null;
		int varsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int varsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<GenericVariable> vars = (List<GenericVariable>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                           		String varName = name.getLexema();
                                GenericVariable genericVariable = new GenericVariable(varName, "int");
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF typeTable = scope.getTypeTable();
                                SymbolTableIF symbolTable = scope.getSymbolTable();
                                checkSymbolDoesNotExists(varName);
                                symbolTable.addSymbol(new SymbolVariable<String>(scope, varName, typeTable.getType("array")));
                                System.out.println(String.format("Array var declaration %s with ", name.getLexema()));
                                vars.add(genericVariable);
                                RESULT=vars;
                             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // lista_variables_matriz ::= IDENTIFICADOR IDENTIFICADOR 
            {
              List<GenericVariable> RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token type = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                String varName = name.getLexema();
                                GenericVariable genericVariable = new GenericVariable(varName, "array");
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF typeTable = scope.getTypeTable();
                                SymbolTableIF symbolTable = scope.getSymbolTable();
                                checkSymbolDoesNotExists(varName);
                                symbolTable.addSymbol(new SymbolVariable<String>(scope, varName, typeTable.getType("array")));
                                System.out.println(String.format("array var declaration %s ", name.getLexema()));
                                List<GenericVariable> vars = new ArrayList();
                                vars.add(genericVariable);
                                RESULT=vars;
                           
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_matriz",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              List<GenericVariable> RESULT =null;
		int varsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		List<GenericVariable> vars = (List<GenericVariable>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                   String varName = name.getLexema();
                                   GenericVariable genericVariable = new GenericVariable(varName, "int", id.getLexema());
                                   ScopeIF scope = scopeManager.getCurrentScope();
                                   TypeTableIF typeTable = scope.getTypeTable();
                                   SymbolTableIF symbolTable = scope.getSymbolTable();
                                   checkSymbolDoesNotExists(varName);
                                   checkSymbolIsNotArray(id.getLexema());
                                   symbolTable.addSymbol(new SymbolVariable<String>(scope, varName, typeTable.getType("int"), id.getLexema()));
                                   System.out.println(String.format("Integer var declaration %s with reference value %d", name.getLexema(), id.getLexema()));
                                   vars.add(genericVariable);
                                   RESULT=vars;
                                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR ASIGNACION NUMERO 
            {
              List<GenericVariable> RESULT =null;
		int varsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int varsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		List<GenericVariable> vars = (List<GenericVariable>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token value = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                String varName = name.getLexema();
                                GenericVariable genericVariable = new GenericVariable(varName, "int", Integer.parseInt(value.getLexema()));
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF typeTable = scope.getTypeTable();
                                SymbolTableIF symbolTable =	scope.getSymbolTable();
                                checkSymbolDoesNotExists(varName);
                                symbolTable.addSymbol(new SymbolVariable<Integer>(scope, varName, typeTable.getType("int"), Integer.parseInt(value.getLexema())));
                                System.out.println(String.format("Integer var declaration %s with value %d", name.getLexema(), Integer.parseInt(value.getLexema())));
                                vars.add(genericVariable);
                                RESULT=vars;
                               
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // lista_variables_enteras ::= lista_variables_enteras COMA IDENTIFICADOR 
            {
              List<GenericVariable> RESULT =null;
		int varsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int varsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<GenericVariable> vars = (List<GenericVariable>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                 String varName = name.getLexema();
                                 GenericVariable genericVariable = new GenericVariable(varName, "int");
                                 ScopeIF scope = scopeManager.getCurrentScope();
                                 TypeTableIF typeTable = scope.getTypeTable();
                                 SymbolTableIF symbolTable = scope.getSymbolTable();
                                 checkSymbolDoesNotExists(varName);
                                 symbolTable.addSymbol(new SymbolVariable<Integer>(scope, varName, typeTable.getType("int")));
                                 System.out.println(String.format("Integer var declaration %s", name.getLexema()));
                                 vars.add(genericVariable);
                                 RESULT=vars;
                               
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION IDENTIFICADOR 
            {
              List<GenericVariable> RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                String varName = name.getLexema();
                                GenericVariable genericVariable = new GenericVariable(varName, "int", id.getLexema());
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF typeTable = scope.getTypeTable();
                                SymbolTableIF symbolTable = scope.getSymbolTable();
                                checkSymbolDoesNotExists(varName);
                                checkSymbolIsNotArray(id.getLexema());
                                symbolTable.addSymbol(new SymbolVariable<String>(scope, varName, typeTable.getType("int"), id.getLexema()));
                                System.out.println(String.format("Integer var declaration %s with reference value %d", name.getLexema(), id.getLexema()));
                                List<GenericVariable> vars = new ArrayList<GenericVariable>();
                                vars.add(genericVariable);
                                RESULT=Collections.singletonList(genericVariable);
                                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // lista_variables_enteras ::= ENTERO IDENTIFICADOR ASIGNACION NUMERO 
            {
              List<GenericVariable> RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token value = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                String varName = name.getLexema();
                                GenericVariable genericVariable = new GenericVariable(varName, "int", Integer.parseInt(value.getLexema()));
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF typeTable = scope.getTypeTable();
                                SymbolTableIF symbolTable =	scope.getSymbolTable();
                                checkSymbolDoesNotExists(varName);
                                symbolTable.addSymbol(new SymbolVariable<Integer>(scope, varName, typeTable.getType("int"), Integer.parseInt(value.getLexema())));
                                System.out.println(String.format("Integer var declaration %s with value %d", name.getLexema(), Integer.parseInt(value.getLexema())));
                                List<GenericVariable> vars = new ArrayList<GenericVariable>();
                                vars.add(genericVariable);
                                RESULT=Collections.singletonList(genericVariable);
                               
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // lista_variables_enteras ::= ENTERO IDENTIFICADOR 
            {
              List<GenericVariable> RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                String varName = name.getLexema();
                                GenericVariable genericVariable = new GenericVariable(varName, "int");
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF typeTable = scope.getTypeTable();
                                SymbolTableIF symbolTable = scope.getSymbolTable();
                                checkSymbolDoesNotExists(varName);
                                symbolTable.addSymbol(new SymbolVariable<Integer>(scope, varName, typeTable.getType("int")));
                                System.out.println(String.format("Integer var declaration %s", name.getLexema()));
                                List<GenericVariable> vars = new ArrayList<GenericVariable>();
                                vars.add(genericVariable);
                                RESULT=Collections.singletonList(genericVariable);
                              
              CUP$parser$result = parser.getSymbolFactory().newSymbol("lista_variables_enteras",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // declar_variable ::= lista_variables_matriz PUNTOYCOMA 
            {
              VariableDeclaration RESULT =null;
		int arrayVarsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int arrayVarsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<GenericVariable> arrayVars = (List<GenericVariable>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                        //arrayVars is List<GenericVariable>
                        RESULT= new VariableDeclaration(arrayVars);
                     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // declar_variable ::= lista_variables_enteras PUNTOYCOMA 
            {
              VariableDeclaration RESULT =null;
		int intVarsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int intVarsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<GenericVariable> intVars = (List<GenericVariable>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                        //intVars is List<GenericVariable>
                        RESULT= new VariableDeclaration(intVars);
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variable",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // rango_matriz ::= CORIZQ expresion CORDER 
            {
              ArrayRange RESULT =null;
		int exprleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int exprright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expression expr = (Expression)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                    RESULT = new ArrayRange(expr);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // rango_matriz_declar ::= CORIZQ IDENTIFICADOR CORDER 
            {
              ArrayRangeDeclaration RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
            if (symbol!=null && symbol instanceof SymbolConstant) {
                SymbolConstant constant = (SymbolConstant) symbol;
                ArrayRangeDeclaration arrayRange = new ArrayRangeDeclaration((Integer) constant.getValue());
                RESULT=arrayRange;
            } else {
                System.out.println(String.format("Integer var declaration %s", id.getLexema()));
            }
     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // rango_matriz_declar ::= CORIZQ NUMERO CORDER 
            {
              ArrayRangeDeclaration RESULT =null;
		int valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token value = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
        ArrayRangeDeclaration arrayRange = new ArrayRangeDeclaration(Integer.parseInt(value.getLexema()));
        RESULT=arrayRange;
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("rango_matriz_declar",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // declar_tipo ::= ENTERO IDENTIFICADOR rango_matriz_declar rango_matriz_declar PUNTOYCOMA 
            {
              Array RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int rangeStartleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rangeStartright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ArrayRangeDeclaration rangeStart = (ArrayRangeDeclaration)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rangeEndleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rangeEndright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ArrayRangeDeclaration rangeEnd = (ArrayRangeDeclaration)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
        checkSymbolDoesNotExists(name.getLexema());
        Array array = new Array(name.getLexema(), rangeStart.getValue(), rangeEnd.getValue());
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF typeTable = scope.getTypeTable();
        TypeArray typeArray = new TypeArray(scope, name.getLexema(), rangeStart.getValue(), rangeEnd.getValue());
        typeTable.addType(name.getLexema(), typeArray);
        SymbolTableIF symbolTable =	scope.getSymbolTable();
        Map<String, ArrayList<Integer>> value = new HashMap();
        symbolTable.addSymbol(new SymbolVariable<Map<String, List<Integer>>>(scope, name.getLexema(), typeTable.getType("array")));
        System.out.println(String.format("Array declaration %s with size %dx%d", name.getLexema(),rangeStart.getValue(),rangeEnd.getValue()));
        RESULT=array;
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // declar_const ::= DEFINE IDENTIFICADOR NUMERO PUNTOYCOMA 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token name = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token value = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                            String constantName = name.getLexema();
                            checkSymbolDoesNotExists(constantName);
                            int constantValue = Integer.parseInt(value.getLexema());
                            Constant constant = new Constant<Integer>(constantName, "int", constantValue);
                            ScopeIF scope = scopeManager.getCurrentScope();
                            TypeTableIF typeTable = scope.getTypeTable();
                            SymbolTableIF symbolTable =	scope.getSymbolTable();
                            symbolTable.addSymbol(new SymbolConstant<Integer>(scope, constantName,typeTable.getType("int"), constantValue));
                            System.out.println(String.format("Constant declaration %s with value %s", name.getLexema(), value.getLexema()));
                            RESULT=constant;
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_const",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // declar_funciones_glo ::= declar_main 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // declar_funciones_glo ::= declar_funcion declar_funciones_glo 
            {
              Object RESULT =null;
		int symbolFunctionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int symbolFunctionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SymbolFunction symbolFunction = (SymbolFunction)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_funciones_glo",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // declar_variables_glo ::= declar_funciones_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // declar_variables_glo ::= declar_variable declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_variables_glo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // declar_tipos_glo ::= declar_variables_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // declar_tipos_glo ::= declar_tipo declar_tipos_glo 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_tipos_glo",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // declar_consts ::= declar_tipos_glo 
            {
              Constant RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declar_consts ::= declar_const declar_consts 
            {
              Constant RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declar_consts",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= NT$1 declar_consts 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;


            ScopeIF scope = scopeManager.openScope("global");
			System.out.println("General scope opened " + scope);

			TypeTableIF typeTable =	scope.getTypeTable();
			typeTable.addType(new TypeSimple(scope, "void"));
			typeTable.addType(new TypeSimple(scope, "int"));
            typeTable.addType(new TypeSimple(scope, "array"));
            typeTable.addType(new TypeSimple(scope, "boolean"));
          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
  		// No modificar esta estructura, aunque se pueden aadir ms acciones semnticas

  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);
  		// En caso de no comentarse las sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no est completo. Esto es debido a que
  		// an no se tendr implementada la generacin de cdigo intermedio ni final.
  		// Para la entrega final debern descomentarse y usarse.

        scopeManager.closeScope();

  		syntaxErrorManager.syntaxInfo("Parsing process ended.");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;

    syntaxErrorManager.syntaxInfo ("Starting parsing...");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

